---
title: "Vibe Coding My Way to AI Infra"
description: "Terraform, Claude & Cloud-Native Monitoring"
author: "Matt Pollock"
date:
  created: 2025-07-18
  updated: 2025-07-21
tags:
  - AI
  - Infrastructure as Code
  - Terraform
  - Azure OpenAI
  - GenAI
  - Cloud Infrastructure
  - DevOps
  - Vibe Coding
  - AI Integration
  - Container Apps
  - Azure Functions
  - AI Slop-Ops
  - Slop-Ops
categories:
  - Infrastructure
  - AI Integration
  - Cloud Engineering
  - Learning Projects
reading_time: "20 min"
---

# üî• Vibe Coding My Way to AI Connected Infra: Claude, Terraform & Cloud-Native Monitoring

## üìñ TL;DR ‚Äì What This Post Covers

- How I used AI tools to build an Azure-based monitoring solution from scratch  
- Lessons learned from developing two full versions (manual vs. Terraform)  
- The good, bad, and wandering of GenAI for infrastructure engineers  
- A working, cost-effective, and fully redeployable AI monitoring stack

## Introduction

This project began, as many of mine do, with a career planning conversation. During a discussion with ChatGPT about professional development and emerging skill areas for 2025, one suggestion stuck with me:

> "You should become an Infrastructure AI Integration Engineer."

It‚Äôs a role that doesn‚Äôt really exist yet ‚Äî but probably should.

What followed was a journey to explore whether such a role could be real. I set out to build an AI-powered infrastructure monitoring solution in Azure, without any formal development background and using nothing but conversations with Claude. This wasn‚Äôt just about building something cool ‚Äî it was about testing whether a seasoned infra engineer could:

- Use GenAI to design and deploy a full solution
- Embrace the unknown and lean into the chaos of LLM-based workflows
- Create something reusable, repeatable, and useful

The first phase of the journey was a local prototype using my Pi5 and n8n for AI workflow automation (see my previous post for that). It worked ‚Äî but it was local, limited, and not exactly enterprise-ready.

So began the cloud migration.

### Why this project mattered

I had two goals:

- ‚úÖ Prove that ‚Äúvibe coding‚Äù ‚Äî using GenAI with limited pre-planning ‚Äî could produce something deployable
- ‚úÖ Build a portfolio project for the emerging intersection of AI and infrastructure engineering

This isn‚Äôt a tutorial on AI monitoring. Instead, it‚Äôs a behind-the-scenes look at what happens when you try to:

- Build something real using AI chat alone
- Translate a messy, manual deployment into clean Infrastructure as Code
- Learn *with* the AI, not just from it

The Terraform modules prove it works.  
The chat logs show how we got there.  
The dashboard screenshots demonstrate the outcome.

> *The next sections cover the journey in two parts: first, the vibe-coded v1; then the Terraform-powered refactor in v2.*

---

## üìö Table of Contents

- [Introduction](#introduction)
- [üìö Table of Contents](#table-of-contents)
- [Part 1: The Prototype](#part-1-the-prototype)
- [Version 1: The Manual Deployment Marathon](#version-1-the-manual-deployment-marathon)
- [Platform and GenAI Choices](#platform-and-genai-choices)
- [üß± Phase 1: Foundation](#phase-1-foundation)
- [üß† Phase 2: Intelligence Layer](#phase-2-intelligence-layer)
- [üé® Phase 3: The User Experience](#phase-3-the-user-experience)
- [üåç Part 2: Why Terraform? Why Now?](#part-2-why-terraform-why-now)
- [üß† Part 3: Working with GenAI ‚Äì The Good, the Bad, and the Wandering](#part-3-working-with-genai-the-good-the-bad-and-the-wandering)
- [üèóÔ∏è Part 4: Building the Stack ‚Äì What Got Built](#part-4-building-the-stack-what-got-built)
- [üßæ Part 5: The Result - A Portable, Reusable AI Monitoring Stack](#part-5-the-result-a-portable-reusable-ai-monitoring-stack)
- [üß† Part 6: Reflections and Lessons Learned](#part-6-reflections-and-lessons-learned)
- [‚úÖ Conclusion](#conclusion)

## Part 1: The Prototype

*(Stage 1 ‚Äì Manual AI-Assisted Deployment)* The Birth of a Vibe-Coded Project

The project didn‚Äôt start with a business requirement ‚Äî it started with curiosity. One evening, mid-career reflection turned into a late-night conversation with ChatGPT:

> "You should become an Infrastructure AI Integration Engineer."

I‚Äôd never heard the term, but it sparked something. With 20+ years in IT infrastructure and the growing presence of AI in tooling, it felt like a direction worth exploring.

### The Thought Experiment

Could I ‚Äî an infrastructure engineer, not a dev ‚Äî build an AI-driven cloud monitoring solution:

- End-to-end, using only AI assistance
- Without dictating the architecture
- With minimal manual planning

The rules were simple:

- ‚ùå No specifying what resources to use
- ‚ùå No formal design documents
- ‚úÖ Just tell the AI the *outcome* I wanted, and let it choose the path

The result: pure "vibe coding." Or as I now call it: **AI Slop-Ops**.

### What is Vibe Coding (a.k.a. Slop-Ops)?

For this project, "vibe coding" meant:

- ü§ñ Generating all infrastructure and app code using natural language prompts
- üß† Letting Claude decide how to structure everything
- ü™µ Learning through experimentation and iteration

> My starting prompt was something like:  
> *"I want to build an AI monitoring solution in Azure that uses Azure OpenAI to analyze infrastructure metrics."*

Claude replied:
> "Let‚Äôs start with a simple architecture: Azure Container Apps for the frontend, Azure Functions for the AI processing, and Azure OpenAI for the intelligence. We'll build it in phases."

That one sentence kicked off a 4‚Äì5 week journey involving:

- ~40‚Äì50 hours of evening and weekend effort üßµ
- Dozens of chats, scripts, and browser tabs
- An unpredictable mix of brilliance and bafflement

And the whole thing started to work.

---

## Version 1: The Manual Deployment Marathon

The first build was fully manual ‚Äî a mix of PowerShell scripts, Azure portal clicks, and Claude-prompting marathons. Claude suggested a phased approach, which turned out to be the only way to keep it manageable.

üí¨ *Claude liked PowerShell. I honestly can‚Äôt remember if that was my idea or if I just went along with it.* ü§∑‚Äç‚ôÇÔ∏è

---

## Platform and GenAI Choices

### üåê Why Azure?

The platform decision was pragmatic:

- I already had a [Visual Studio Developer Subscription](https://learn.microsoft.com/en-us/visualstudio/subscriptions/) with ¬£120/month of Azure credits.
- Azure is the cloud provider I work with day-to-day, so it made sense to double down.
- Using Azure OpenAI gave me hands-on experience with **Azure AI Foundry** ‚Äì increasingly relevant in modern infrastructure roles.

In short: low cost, high familiarity, and useful upskilling.

---

### üß† Why Claude?

This project was built almost entirely through chat with **Claude**, Anthropic‚Äôs conversational AI. I‚Äôve found:

‚úÖ **Claude is better at structured technical responses**, particularly with IaC and shell scripting.  
‚ùå **ChatGPT tends to hallucinate more often** in my experience when writing infrastructure code.

But Claude had its own quirks too:

- No memory between chats ‚Äî every session required reloading context.
- Occasional focus issues ‚Äî drifting from task or overcomplicating simple requests.
- Tendency to suggest hardcoded values when debugging ‚Äî needing constant vigilance to maintain DRY principles.

> ‚ö†Ô∏è Reality check: Claude isn't a Terraform expert. It's a language model that *guesses well* based on input. The human still needs to guide architecture, validate outputs, and ensure everything actually works.

---

### ü§ñ Prompt Engineering Principles

I used a consistent framework to keep Claude focused and productive:

- **ROLE**: Define Claude's purpose (e.g., ‚ÄúYou are a Terraform expert‚Äù)
- **INPUT**: What files or context is provided
- **OUTPUT**: What should Claude return (e.g., a module, refactored block, explanation)
- **CONSTRAINTS**: e.g., ‚ÄúNo hardcoded values‚Äù, ‚ÄúUse locals not repeated variables‚Äù
- **TASK**: Specific action or generation requested
- **REMINDERS**: Extra nudges ‚Äî ‚ÄúUse comments‚Äù, ‚ÄúOutput in markdown‚Äù, ‚ÄúUse Azure CLI not PowerShell‚Äù

> This approach reduced misunderstandings and helped prevent ‚Äúsolution drift‚Äù during long iterative sessions.

---

## üß± Phase 1: Foundation

This first phase set up the core infrastructure that everything else would build upon.

### üîß What Got Built

- **Resource Groups** ‚Äì Logical container for resources  
- **Storage Accounts** ‚Äì Persistent storage for logs, state, and AI interaction data  
- **Log Analytics Workspace** ‚Äì Centralized logging for observability  
- **Application Insights** ‚Äì Telemetry and performance monitoring for apps

These services created the backbone of the environment, enabling both operational and analytical insight.

---

### üñ•Ô∏è PowerShell Verification Script

This example script was used during v1 to manually verify deployment success:

```powershell
# Verify everything is working
Write-Host "üîç Verifying Step 1.1 completion..." -ForegroundColor Yellow

# Check resource group
$rg = Get-AzResourceGroup -Name "rg-ai-monitoring-dev" -ErrorAction SilentlyContinue
if ($rg) {
    Write-Host "‚úÖ Resource Group exists" -ForegroundColor Green
} else {
    Write-Host "‚ùå Resource Group not found" -ForegroundColor Red
}

# Check workspace
$ws = Get-AzOperationalInsightsWorkspace -ResourceGroupName "rg-ai-monitoring-dev" -Name "law-ai-monitoring-dev" -ErrorAction SilentlyContinue
if ($ws -and $ws.ProvisioningState -eq "Succeeded") {
    Write-Host "‚úÖ Log Analytics Workspace is ready" -ForegroundColor Green
} else {
    Write-Host "‚ùå Log Analytics Workspace not ready. State: $($ws.ProvisioningState)" -ForegroundColor Red
}

# Check config file
if (Test-Path ".\phase1-step1-config.json") {
    Write-Host "‚úÖ Configuration file created" -ForegroundColor Green
} else {
    Write-Host "‚ùå Configuration file missing" -ForegroundColor Red
}
```

## üß† Phase 2: Intelligence Layer

With the foundation in place, the next step was to add the brainpower ‚Äî the AI and automation components that turn infrastructure data into actionable insights.

### üß© Key Components

- **Azure OpenAI Service**
  - Deployed with `gpt-4o-mini` to balance cost and performance
  - Powers the natural language analysis and recommendation engine

- **Azure Function App**
  - Hosts the core AI processing logic
  - Parses data from monitoring tools and feeds it to OpenAI
  - Returns interpreted insights in a format suitable for dashboards and alerts

- **Logic Apps**
  - Automates data ingestion and flow between services
  - Orchestrates the processing of logs, telemetry, and alert conditions
  - Acts as glue between Function Apps, OpenAI, and supporting services

---

### üó£Ô∏è AI Integration Philosophy

This stage wasn‚Äôt about building complex AI logic ‚Äî it was about using OpenAI to interpret patterns in infrastructure data and return intelligent summaries or recommendations in natural language.

> Example prompt fed to OpenAI from within a Function App:
>
> ‚ÄúBased on this log stream, are there any signs of service degradation or performance issues in the last 15 minutes?‚Äù

The response would be embedded in a monitoring dashboard or sent via alert workflows, giving human-readable insights without manual interpretation.

---

### ‚öôÔ∏è Why This Setup?

Each component in this layer was chosen for a specific reason:

- **OpenAI** for flexible, contextual intelligence  
- **Function Apps** for scalable, event-driven execution  
- **Logic Apps** for orchestration without writing custom backend code  

This approach removed the need for always-on VMs or bespoke integrations ‚Äî and kept things lean.

---

üìå *By the end of Phase 2, the system had a functioning AI backend that could interpret infrastructure metrics in plain English and respond in near real-time.*

## üé® Phase 3: The User Experience

With the core infrastructure and AI processing in place, it was time to build the frontend ‚Äî the visible interface for users to interact with the AI-powered monitoring system.

This phase focused on deploying a set of containerized applications, each responsible for a specific role in the monitoring workflow.

---

### üß± Components Deployed

The solution was built around **Azure Container Apps**, with a four-container ecosystem designed to work in harmony:

- **FastAPI Backend**  
  Handles API requests, routes data to the correct services, and acts as the core orchestrator behind the scenes.

- **React Dashboard**  
  A clean, responsive frontend displaying infrastructure metrics, system health, and AI-generated insights.

- **Background Processor**  
  Continuously monitors incoming data and triggers AI evaluations when certain thresholds or patterns are detected.

- **Load Generator**  
  Provides synthetic traffic and test metrics to simulate real usage patterns and help validate system behavior.

---

### üîÑ Why This Architecture?

Each container serves a focused purpose, allowing for:

- **Isolation of concerns** ‚Äî easier debugging and development
- **Scalable deployment** ‚Äî each component scales independently
- **Separation of UI and logic** ‚Äî keeping the AI and logic layers decoupled from the frontend

> ‚ÄúClaude recommended this separation early on ‚Äî the decision to use Container Apps instead of AKS or App Services kept costs down and complexity low, while still providing a modern cloud-native experience.‚Äù

---

### ‚öôÔ∏è Deployment Highlights

Container Apps were provisioned via CLI in the manual version, and later through Terraform in v2. The deployment process involved:

- Registering a **Container Apps Environment**
- Creating the four separate app containers
- Passing environment variables for API endpoints, keys, and settings
- Enabling diagnostics and logging via Application Insights

```bash
az containerapp create \
  --name react-dashboard \
  --image myregistry.azurecr.io/dashboard:latest \
  --env-vars REACT_APP_API_URL=https://api.example.com
```

### üìä Final Result

Once deployed, the user-facing layer provided:

- üîç **Real-time visual metrics**
- üí° **AI-generated recommendations**
- üß† **Interactive analysis via chat**
- üìà **Infrastructure performance summaries**
- üí¨ **Stakeholder-friendly reporting**

This phase brought the system to life ‚Äî from backend AI logic to a polished, interactive dashboard.

### ü§ñ The Reality of AI-Assisted Development

Here's what the success story doesn‚Äôt capture: the relentless battles with Claude‚Äôs limitations.

Despite its capabilities, working with GenAI in a complex, multi-phase project revealed real friction points ‚Äî especially when continuity and context were critical.

#### üò´ Daily Frustrations Included

- üß± **Hitting chat length limits daily** ‚Äî even with Claude Pro
- üß≠ **AI meandering off-topic**, despite carefully structured prompts
- üìö **Over-analysis** ‚Äî asking for one thing and receiving a detailed architectural breakdown
- ‚öôÔ∏è **Token burn during troubleshooting** ‚Äî Claude often provided five-step fixes when a one-liner was needed
- ‚ùå **No persistent memory or project history**
  - This meant manually copy/pasting prior chats into a `.txt` file just to refeed them back in
- üîÅ **Starting new chats daily** ‚Äî and re-establishing context from scratch every time
- üìè **Scope creep** ‚Äî Claude regularly expanded simple requests into full architectural reviews without being asked

Despite these pain points, the experience was still a net positive ‚Äî but only because I was prepared to steer the conversation firmly and frequently.
![Chat length limit warning](./Claude_ChatLengthLImit.png)

#### üß™ From Real-World Troubleshooting

Sometimes, working with Claude felt like pair programming with a colleague who had perfect recall ‚Äî until they completely wiped their memory overnight.

> üßµ **From an actual troubleshooting session:**
>
> ‚ÄúThe dashboard is calling the wrong function URL again.  
> It‚Äôs trying to reach `func-tf-ai-monitoring-dev-ai`,  
> but the actual function is at `func-ai-monitoring-dev-ask6868-ai`.‚Äù

It was a recurring theme: great memory during a session, zero continuity the next day.

> **Me:** ‚ÄúRight, shall we pick up where we left off yesterday then?‚Äù  
> **Claude:** ‚ÄúI literally have no idea what you're talking about, mate.‚Äù  
> **Claude:** ‚ÄúWait, who are you again?‚Äù

Every failure taught *both* me and Claude something ‚Äî but the learning curve was steep, and the iteration cycles could be genuinely exhausting.

### Version 1 - Deployed & Working

![AI Monitoring Dashboard V1](./AIMonitoringDashboardV1.png)

### üß† What I Learned from Part 1

Reflecting on the first phase of this project ‚Äî the manual, vibe-coded deployment ‚Äî several key takeaways emerged.

#### ‚úÖ What Worked Well

- ‚ö° **Rapid prototyping** ‚Äî quickly turned ideas into functioning infrastructure
- üí¨ **Natural language problem-solving** ‚Äî great for tackling Azure‚Äôs complex service interactions
- üßæ **Syntactically sound code generation** ‚Äî most outputs worked with minimal tweaks
- ‚è±Ô∏è **Massive time savings** ‚Äî tasks that might take days manually were completed in hours

#### üîç What Needed Constant Oversight

- üß† **Keeping the AI focused** ‚Äî drift and distraction were constant threats
- üîó **Managing dependencies and naming** ‚Äî conflicts and collisions needed manual intervention
- üêõ **Debugging runtime issues** ‚Äî particularly frustrating when errors only manifested in Azure
- üß≠ **Architectural decisions** ‚Äî strategic direction still had to come from me
- ‚ö†Ô∏è **Knowing when ‚Äúit works‚Äù wasn‚Äôt ‚Äúproduction-ready‚Äù** ‚Äî validation remained a human job

#### üõ†Ô∏è Language & Tooling Choices

Interestingly, **Claude dictated the stack** more than I did.

- **Version 1** leaned heavily on **PowerShell**
- **Version 2** shifted to **Azure CLI and Bash**

Despite years of experience with PowerShell, I found Claude was significantly more confident (and accurate) when generating Azure CLI or Bash-based commands. This influenced the eventual choice to move away from PowerShell in the second iteration.

---

By the end of Part 1, I had a functional AI monitoring solution ‚Äî but it was fragile, inconsistent, and impossible to redeploy without repeating all the manual steps.

That realisation led directly to **Version 2** ‚Äî a full rebuild using Infrastructure as Code.

---

## üåç Part 2: Why Terraform? Why Now?

After several weeks of manual deployments, the **limitations of version 1** became unmissable.

Yes ‚Äî the system *worked* ‚Äî but only just:

- Scripts were fragmented and inconsistent  
- Fixes required custom, ad-hoc scripts created on the fly  
- Dependencies weren‚Äôt tracked, and naming conflicts crept in  
- Reproducibility? Practically zero  

üö® The deployment process had become **unwieldy** ‚Äî a sprawl of folders, partial fixes, and manual interventions. Functional? Sure. Maintainable? Absolutely not.

---

That‚Äôs when the **Infrastructure as Code (IaC)** mindset kicked in.

> *‚ÄúAnything worth building once is worth building repeatably.‚Äù*

The question was simple:  
üí° *Could I rebuild everything from scratch ‚Äî but this time, using AI assistance to create clean, modular, production-ready Terraform code?*

---

### üß± The Terraform Challenge

Rebuilding in Terraform wasn‚Äôt just a choice of tooling ‚Äî it was a **challenge to see how far AI-assisted development could go** when held to production-level standards.

#### üéØ Goals of the Terraform Rewrite

- **Modularity**  
  Break down the monolithic structure into **reusable, isolated modules**  
- **Portability**  
  Enable consistent deployment **across environments and subscriptions**
- **DRY Principles**  
  Absolutely **no hardcoded values** or duplicate code
- **Documentation**  
  Ensure the code was **clear, self-documenting**, and reusable by others

---

Terraform wasn‚Äôt just a tech choice ‚Äî it became the **refinement phase**.  
A chance to take what I‚Äôd learned from the vibe-coded version and bake that insight into clean, structured infrastructure-as-code.

Next: how AI and I tackled that rebuild, and the (sometimes surprising) choices we made.

### üß† The Structured Prompt Approach

The **prompt engineering** approach became absolutely crucial during the Terraform refactoring phase.

Rather than relying on vague questions or ‚Äúdo what I mean‚Äù instructions, I adopted a structured briefing style ‚Äî the kind you might use when assigning work to a consultant:

- Define the **role**
- Set the **goals**
- Describe the **inputs**
- Outline the **method**
- Impose **constraints**

---

Here‚Äôs the **actual instruction prompt** I used to initiate the Terraform rebuild üëá

```bash
üîß Enhanced Prompt: AI Monitoring Solution IaC Refactoring Project

üë§ Role Definition
You are acting as:
‚Ä¢ An Infrastructure as Code (IaC) specialist with deep expertise in Terraform
‚Ä¢ An AI integration engineer, experienced in deploying Azure-based AI workloads

Your responsibilities are:
‚Ä¢ To refactor an existing AI Monitoring solution from a manually built prototype 
  into a modular, efficient, and portable Terraform project
‚Ä¢ To minimize bloat, ensure code reusability, and produce clear documentation 
  to allow redeployment with minimal changes

üéØ Project Goals
‚Ä¢ Rebuild the existing AI Monitoring solution as a fully modular, DRY-compliant 
  Terraform deployment
‚Ä¢ Modularize resources (OpenAI, Function Apps, Logic Apps, Container Apps) 
  into reusable components
‚Ä¢ Provide clear, concise README.md files for each module describing usage, 
  input/output variables, and deployment steps

üìÅ Project Artifacts (Input)
The following components are part of the original Azure-hosted AI Monitoring solution:
‚Ä¢ Azure OpenAI service
‚Ä¢ Azure Function App
‚Ä¢ Logic App
‚Ä¢ Web Dashboard
‚Ä¢ Container Apps Environment
‚Ä¢ Supporting components (Key Vaults, App Insights, Storage, etc.)

üõ†Ô∏è Approach / Methodology
For each module:
‚Ä¢ Use minimal but complete resource blocks
‚Ä¢ Include only essential variables with sensible defaults
‚Ä¢ Use output values to export key resource properties
‚Ä¢ Follow DRY principles using locals or reusable variables where possible

üìå Additional Guidelines
‚Ä¢ Efficiency first: Avoid code repetition; prefer reusability, locals, and input variables
‚Ä¢ Practical defaults: Pre-fill variables with production-safe, but general-purpose values
‚Ä¢ Keep it modular: No monolithic deployment blocks‚Äîuse modules for all core resources
‚Ä¢ Strict adherence: Do not expand scope unless confirmed
```

This structured approach helped maintain focus and provided clear boundaries for the AI to work within ‚Äî though, as you'll see, **constant reinforcement was still required** throughout the process.

---

### üîÑ The Refactoring Process

The Terraform rebuild became a **different kind of AI collaboration**.

Where version 1 was about vibing ideas into reality, version 2 was about **methodically translating a messy prototype into clean, modular, production-friendly code**.

---

#### üß© Key Modules Created

- `foundation`  
  Core infrastructure ‚Äî resource groups, storage accounts, logging, etc.
  
- `openai`  
  Azure OpenAI resource and model deployment ‚Äî central to the intelligent analysis pipeline

- `function-app`  
  Azure Functions for AI processing ‚Äî connecting telemetry with insights

- `container-apps`  
  Four-container ecosystem ‚Äî the user-facing UI and visualization layers

- `monitoring`  
  Application Insights + alerting ‚Äî keeping the system observable and maintainable

---

#### üìÅ Modular Structure Overview

```bash
terraform-ai-monitoring/
‚îú‚îÄ‚îÄ modules/
‚îÇ   ‚îú‚îÄ‚îÄ foundation/
‚îÇ   ‚îú‚îÄ‚îÄ openai/
‚îÇ   ‚îú‚îÄ‚îÄ function-app/
‚îÇ   ‚îî‚îÄ‚îÄ container-apps/
‚îú‚îÄ‚îÄ main.tf
‚îî‚îÄ‚îÄ terraform.tfvars
```

Each module went through **multiple refinement cycles**. The goal wasn‚Äôt just to get it working ‚Äî it was to ensure:

- Clean, reusable Terraform code
- Explicit configuration
- DRY principles throughout
- Reproducible, idempotent deployments

---

#### üîß Iterative Refinement in Practice

A typical troubleshooting session went something like this:

- I‚Äôd run the code or attempt a terraform plan or apply.
- If there were no errors, I‚Äôd verify the outcome and move on.
- If there were errors, I‚Äôd copy the output into Claude and we‚Äôd go back and forth trying to fix the problem.

This is where things often got tricky. Claude would sometimes suggest hardcoded values despite earlier instructions to avoid them, or propose overly complex fixes instead of the simple, obvious one. Even with clear guidance in the prompt, it was a constant effort to keep the AI focused and within scope.

The process wasn‚Äôt just code generation ‚Äî it was troubleshooting, adjusting, and rechecking until things finally worked as expected.

![Terraform schema correction](./Claude_Terraform_Chat_Error_Example.png)

The process revealed both the strengths and limitations of AI-assisted Infrastructure as Code development.

---

## üß† Part 3: Working with GenAI ‚Äì The Good, the Bad, and the Wandering

Building two versions of the same project entirely through AI conversations provided unique insights into the **practical realities of AI-assisted development**.

This wasn‚Äôt the utopian "AI will do everything" fantasy ‚Äî nor was it the cynical "AI can‚Äôt do anything useful" view.  
It was somewhere in between: **messy, human, instructive**.

---

### ‚úÖ The Good: Where AI Excelled

**‚ö° Rapid prototyping and iteration**  
Claude could produce working infrastructure code faster than I could even open the Azure documentation.  
Need a Container App with specific environment variables? ‚úÖ Done.  
Modify the OpenAI integration logic? ‚úÖ Updated in seconds.

**üß© Pattern recognition and consistency**  
Once Claude grasped the structure of the project, it stuck with it.  
Variable names, tagging conventions, module layout ‚Äî it stayed consistent without me needing to babysit every decision.

**üõ†Ô∏è Boilerplate generation**  
Claude churned out huge volumes of code across Terraform, PowerShell, React, and Python ‚Äî all **syntactically correct and logically structured**, freeing me from repetitive coding.

---

### ‚ùå The Bad: Where AI Struggled

**üß† Context drift and prompt guardrails**  
Even with structured, detailed instructions, Claude would sometimes go rogue:  

- Proposing solutions for problems I hadn‚Äôt asked about  
- Rewriting things that didn‚Äôt need fixing  
- Suggesting complete redesigns for simple tweaks  

**üéâ Over-enthusiasm**  
Claude would often blurt out things like:  
> *‚ÄúCONGRATULATIONS!! üéâ You now have a production-ready AI Monitoring platform!‚Äù*  
To which I‚Äôd reply:  
> *‚ÄúEr, no bro. We're nowhere near done here. Still Cuz.‚Äù*

(Okay, I don‚Äôt *really* talk to Claude like a GenZ wannabe Roadman ‚Äî but you get the idea üòÇ)

**üêõ Runtime debugging limitations**  
Claude could *write* the code. But fixing things like:  

- Azure authentication issues  
- Misconfigured private endpoints  
- Resource naming collisions  
‚Ä¶was always on me. These weren‚Äôt things AI could reliably troubleshoot on its own.

**üîÅ Project continuity fail**  
There‚Äôs no persistent memory.  
Every new session meant reloading context from scratch ‚Äî usually by copy-pasting yesterday‚Äôs chat into a new one.  
Tedious, error-prone, and inefficient.

---

### üåÄ The Wandering: Managing AI Attention

**‚ö†Ô∏è Fundamental challenge: No memory**  
Claude has no memory beyond the current chat. Even structured prompts didn‚Äôt prevent ‚Äúchat drift‚Äù unless I constantly reinforced boundaries.
This is where ChatGPT has an edge in my opiion.
If I ask about previous chats, ChatGPT can give me examples and context about chats we had previously if prompted.

**üéØ The specificity requirement**  
Vague:  
> "Fix the container deployment"  
Resulted in:  
> "Let‚Äôs rebuild the entire architecture from scratch" üò¨  

Precise:  
> "Update the environment variable `REACT_APP_API_URL` in `container-apps` module"  
Got the job done.

**üö´ The hardcoded value trap**  
Claude loved quick fixes ‚Äî often hardcoding values just to ‚Äúmake it work‚Äù.  
I had to go back and **de-hardcode** everything to stay true to the DRY principles I set from day one.

**‚è≥ Time impact for non-devs
Both stages of the project took longer than they probably should have ‚Äî not because of any one flaw, but because of the nature of working with AI-generated infrastructure code.

A seasoned DevOps engineer might have moved faster by spotting bugs earlier and validating logic more confidently. But a pure developer? Probably not. They‚Äôd likely struggle with the Azure-specific infrastructure decisions, access policies, and platform configuration that were second nature to me.

This kind of work sits in a grey area ‚Äî it needs both engineering fluency and platform experience. The real takeaway? GenAI can bridge that gap in either direction, but whichever way you‚Äôre coming from, there‚Äôs a learning curve.

The cost: higher validation effort.  
The reward: greater independence and accelerated learning.

---

## üèóÔ∏è Part 4: Building The Stack - What Got Built

The final Terraform solution creates a fully integrated AI monitoring ecosystem in Azure ‚Äî one that‚Äôs modular, intelligent, and *almost* production-ready.  
Here‚Äôs what was actually built ‚Äî and why.

---

### üîß Core Architecture

**üß† Azure OpenAI Integration**  
At the heart of the system is GPT-4o-mini, providing infrastructure analysis and recommendations at a significantly lower cost than GPT-4 ‚Äî without compromising on quality for this use case.

**üì¶ Container Apps Environment**  
Four lightweight, purpose-driven containers manage the monitoring workflow:

- ‚öôÔ∏è **FastAPI backend** ‚Äì Data ingestion and processing
- üìä **React dashboard** ‚Äì Front-end UI and live telemetry
- üîÑ **Background processor** ‚Äì Continuously monitors resource health
- üöÄ **Load generator** ‚Äì Simulates traffic for stress testing and metrics

**‚ö° Azure Function Apps for AI Processing**  
Serverless compute bridges raw telemetry with OpenAI for analysis.  
Functions scale on demand, keeping costs low and architecture lean.

> ‚ö†Ô∏è The only part of the project not handled in Terraform was the custom dashboard container build.
> That's by design ‚Äî Terraform isn‚Äôt meant for image building or pushing.
> Instead, I handled that manually (or via CI pipeline), which aligns with Hashicorps ![best practices](https://developer.hashicorp.com/terraform/docs/language/resources/externally-managed).

---

### üß∞ Supporting Infrastructure

- **Application Insights** ‚Äì Real-time telemetry for diagnostics
- **Log Analytics** ‚Äì Centralised logging and query aggregation
- **Azure Container Registry (ACR)** ‚Äì Stores and serves custom container images
- **Key Vault** ‚Äì Secrets management for safe credential handling

---

### ü§î Key Technical Decisions

**üÜö Why Container Apps instead of AKS?**  
Honestly? Claude made the call.  
When I described what I needed (multi-container orchestration without complex ops), Claude recommended **Container Apps over AKS**, citing:  

- Lower cost  
- Simpler deployment  
- Sufficient capability for this workload  

And‚Ä¶ Claude was right. AKS would have been overkill.

**üí∏ Why GPT-4o-mini over GPT-4?**  
This was a no-brainer. GPT-4o-mini gave near-identical results for our monitoring analysis ‚Äî at a **fraction of the cost**.  
Perfect balance of performance and budget.

**üì¶ Why modular Terraform over monolithic deployment?**  
Because chaos is not a deployment strategy.  
Modular code = clean boundaries, reusable components, and simple environment customization.  
It‚Äôs easier to debug, update, and scale.

---

### üßÆ Visual Reference

Below are visuals captured during project development and testing:

**üîπ VS Code project structure**  
![VS Code project structure](./VSCode_Terraform_Project_Structure.png)

**üîπ Claude Projects interface**  
![Claude Projects interface](./Claude_Project_Screenshot.png)

---

### üìä What the Dashboard Shows

The final React-based dashboard delivers:

- ‚úÖ **Real-time API health checks**
- üß† **AI-generated infrastructure insights**
- üìà **Performance metrics + trend analysis**
- üí¨ **Interactive chat with OpenAI**
- üì§ **Exportable chats for analysis**

**üîπ Dashboard ‚Äì Full view**  
![Dashboard Full View](./AIMonitoringDashboard_Final.png)

**üîπ AI analysis in progress**  
![Dashboard AI analysis 2](./AIMonitoringDashboard_2.png)

**üîπ OpenAI response card**  
![OpenAI response](./AIMonitoringDashboard.png)

---

## üßæ Part 5: The Result - A Portable, Reusable AI Monitoring Stack

The final Terraform deployment delivers a **complete, modular, and production-friendly AI monitoring solution** ‚Äî fully reproducible across environments. More importantly, it **demonstrates that AI-assisted infrastructure creation is not just viable, but effective** when paired with good practices and human oversight.

---

### üöÄ Deployment Experience

**From zero to running dashboard:**  
~ **15 minutes (give or take 30-40 hours üòÇ)**

```bash
terraform init
terraform plan
terraform apply
```

Minimal configuration required:

- ‚úÖ Azure subscription credentials
- üìÑ Terraform variables (project name, region, container image names, etc.)
- üê≥ Container image references (can use defaults or custom builds)

---

### üó∫Ô∏è Infrastructure Overview

The final deployment provisions a complete, AI-driven monitoring stack ‚Äî built entirely with Infrastructure as Code and connected through modular Terraform components.

**üîπ Azure Resource Visualizer**  
![Azure Resource Visualizer](./Azure_Resources.png)

---

### üí∞ Cost Optimization

This solution costs **~¬£15 per month** for a dev/test deployment (even cheaper if you remember to turn the container apps off!üò≤) ‚Äî vastly cheaper than typical enterprise-grade monitoring tools (which can range ¬£50‚Äì¬£200+ per month).

**Key savings come from:**

- ‚ö° Serverless Functions instead of always-on compute
- üì¶ Container Apps that scale to zero during idle time
- ü§ñ GPT-4o-mini instead of GPT-4 (with negligible accuracy trade-off)

---

### üîÅ Portability Validation

The real benefit of this solution is in its **repeatability**:

‚úÖ **Dev environment**  
UK South, full-feature stack

‚úÖ **Test deployment**  
New resource group, same subscription ‚Äî **identical results**

‚úÖ **Clean subscription test**  
Fresh environment, zero config drift

**Conclusion:**  
No matter where or how it's deployed, the **stack just works**.

---

## üß† Part 6: Reflections and Lessons Learned

Building the same solution twice ‚Äî once manually, once using Infrastructure as Code ‚Äî offered a unique lens through which to view both **AI-assisted development** and **modern infrastructure practices**.

---

### ü§ñ On AI-Assisted Development

**üîé The reality check**  
AI-assisted development is **powerful but not autonomous**. It still relies on:

- Human oversight
- Strategic decisions
- Recognizing when the AI is confidently wrong

**‚ö° Speed vs. Quality**  
AI can produce working code fast ‚Äî sometimes scarily fast ‚Äî but:

- The **validation/debugging** can take *longer* than traditional coding
- The real power lies in **architectural iteration**, not production-readiness

**üìö The learning curve**  
Truthfully, both v1 and v2 took **much longer than they should have**.  
A seasoned developer with better validation skills could likely complete either project in **half the time** ‚Äî by catching subtle issues earlier.

---

### üõ†Ô∏è On Infrastructure as Code

**üìê The transformation**  
Switching to Terraform wasn‚Äôt just about reusability:

- It encouraged **cleaner design**, **logical resource grouping**, and **explicit dependencies**
- It *forced* better decisions

**üß© The hidden complexity**  
What looked simple in Terraform:

- Revealed just how **messy** the manual deployment had been
- Every implicit assumption, naming decision, and ‚Äújust click here‚Äù moment had to become **codified and reproducible**

---

### üé≠ On Vibe Coding as a Methodology

**‚úÖ What worked:**

- Rapid architectural exploration
- Solving problems in plain English
- Iterative builds based on feedback
- AI-assisted speed gains (things built in hours, not days)

**‚ùå What didn‚Äôt:**

- Continuity across chat sessions
- Preserving project context
- Runtime debugging in Azure
- Keeping the agent focused on scoped tasks

---

### üîÅ Things I‚Äôd Do Differently

**üßæ Better structured prompting from the outset**  
While I used a defined structure for the AI prompt, I learned:

- Even good prompts **require ongoing reinforcement**
- Claude needed regular reminders to stay on track during long sessions

**‚úÖ Regular resource validation**  
A recurring challenge:

- Claude often **over-provisioned** services
- Periodic reviews of what we were building helped cut waste and simplify architecture

**üß† The reality of AI memory limitations**  
No, the AI does not ‚Äúremember‚Äù anything meaningful between sessions:

- Every day required **rebuilding the conversation context**
- Guardrails had to be **restated** often

**üéØ The extreme specificity requirement**  
Vague asks = vague solutions  
But:

- **Precise requests** like ‚Äúupdate `REACT_APP_API_URL` in `container-apps` module‚Äù yielded laser-targeted results

---

## ‚úÖ Conclusion

This project started as a career thought experiment ‚Äî *‚ÄúWhat if there was a role focused on AI-integrated infrastructure?‚Äù* ‚Äî and ended with a fully functional AI monitoring solution deployed in Azure.

What began as a prototype on a local Pi5 evolved into a robust, modular Terraform deployment. Over 4‚Äì5 weeks, it generated **thousands of lines of infrastructure code**, countless iterations, and a treasure trove of insights into AI-assisted development.

---

### üöÄ The Technical Outcome

The result is a **portable, cost-effective, AI-powered monitoring system** that doesn‚Äôt just work ‚Äî it *proves a point*. It's not quite enterprise-ready, but it‚Äôs a solid proof-of-concept and a foundation for learning, experimentation, and future iteration.

---

### üß† Key Takeaways

1. **AI-assisted development is powerful ‚Äî but not autonomous.**  
   It requires constant direction, critical oversight, and the ability to spot when the AI is confidently wrong.

2. **Infrastructure as Code changes how you architect.**  
   Writing Terraform forces discipline: clean structure, explicit dependencies, and reproducible builds.

3. **Vibe coding has a learning curve.**  
   Both versions took longer than expected. A seasoned developer could likely move faster ‚Äî but for infra pros, this is how we learn.

4. **Context management is still a major limitation.**  
   The inability to persist AI session memory made long-term projects harder than they should have been.

5. **The role of ‚ÄúInfrastructure AI Integration Engineer‚Äù is real ‚Äî and emerging.**  
   This project sketches out what that future job might involve: blending IaC, AI, automation, and architecture.

---

### üß≠ What‚Äôs Next?

Version 3 is already brewing ‚òï ‚Äî ideas include:

- Monitoring more Azure services
- Improving the dashboard‚Äôs AI output formatting
- Experimenting with newer tools like **Claude Code** and **ChatGPT Codex**
- Trying AI-native IDEs and inline assistants to streamline the workflow

And let‚Äôs not forget the rise of **‚ÄúSlop-Ops‚Äù** ‚Äî that beautiful mess where AI, infrastructure, and vibe-based engineering collide üòé

---

### üí° Final Thoughts

If you're an infrastructure engineer looking to explore AI integration, here‚Äôs the reality:

- The tools are ready.
- The method works.
- But it‚Äôs not magic ‚Äî **it takes effort, patience, and curiosity**.

The future of infrastructure might be conversational ‚Äî but it‚Äôs not (yet) automatic.

---

> If you‚Äôve read this far ‚Äî thanks. üôè
> I‚Äôd love feedback from anyone experimenting with AI-assisted IaC or Terraform refactors.
> Find me on [LinkedIn] or leave a comment.
